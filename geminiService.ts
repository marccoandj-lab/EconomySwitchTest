
import { GoogleGenAI, Type } from "@google/genai";
import { AIQuestion, AIEnumeration } from "./types";

// Helper for exponential backoff
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

const callWithRetry = async (fn: () => Promise<any>, retries = 3, delay = 1000): Promise<any> => {
  try {
    return await fn();
  } catch (error: any) {
    if (retries > 0 && (error?.message?.includes('429') || error?.status === 429)) {
      console.warn(`Rate limit hit. Retrying in ${delay}ms... (${retries} retries left)`);
      await sleep(delay);
      return callWithRetry(fn, retries - 1, delay * 2);
    }
    throw error;
  }
};

const LOCAL_FALLBACK_QUESTIONS: Record<'ECONOMY' | 'SUSTAINABILITY', AIQuestion[]> = {
  ECONOMY: [
    {
      question: "What does 'Inflation' primarily mean?",
      options: ["Rising prices", "Lower taxes", "More jobs", "Higher savings"],
      correctIndex: 0,
      explanation: "Inflation is the rate at which the general level of prices for goods and services is rising.",
      category: 'ECONOMY'
    },
    {
      question: "Which asset is considered 'liquid'?",
      options: ["Real Estate", "Cash", "Fine Art", "Gold Bars"],
      correctIndex: 1,
      explanation: "Liquidity refers to how quickly an asset can be converted into cash without affecting its price.",
      category: 'ECONOMY'
    }
  ],
  SUSTAINABILITY: [
    {
      question: "What is a 'Carbon Footprint'?",
      options: ["Walking in soot", "Greenhouse gas total", "Forest size", "Soil health"],
      correctIndex: 1,
      explanation: "A carbon footprint is the total amount of greenhouse gases generated by our actions.",
      category: 'SUSTAINABILITY'
    },
    {
      question: "What is the 'Circular Economy'?",
      options: ["Round buildings", "Recycling/reusing", "Global trade", "Inflation cycles"],
      correctIndex: 1,
      explanation: "A circular economy aims to eliminate waste and the continual use of resources.",
      category: 'SUSTAINABILITY'
    }
  ]
};

const LOCAL_FALLBACK_ENUMS: Record<'ECONOMY' | 'SUSTAINABILITY', AIEnumeration[]> = {
  ECONOMY: [
    {
      theme: "Banking & Finance Institutions",
      expectedTerms: ["Central Bank", "Commercial Bank", "Credit Union", "Investment Bank", "World Bank", "IMF", "Stock Exchange", "Brokerage", "Insurance Company", "Hedge Fund", "Treasury", "Federal Reserve", "Mint", "Lender", "Mortgage Firm"],
      reward: 45000,
      category: 'Financial Literacy'
    }
  ],
  SUSTAINABILITY: [
    {
      theme: "Renewable Energy Sources",
      expectedTerms: ["Solar", "Wind", "Hydroelectric", "Geothermal", "Biomass", "Tidal", "Wave", "Hydrogen", "Nuclear Fusion", "Biofuel", "Ocean Thermal", "Concentrated Solar", "Photovoltaic", "Wind Turbine", "Dam"],
      reward: 50000,
      category: 'Ecosystem'
    }
  ]
};

export const getAIQuestion = async (
  context: 'ECONOMY' | 'SUSTAINABILITY',
  excludedQuestions?: string[]
): Promise<AIQuestion> => {
  const fetchQuestion = async () => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const excludeText = excludedQuestions && excludedQuestions.length > 0
      ? ` Do NOT use any of these already-asked questions: ${excludedQuestions.join('; ')}.`
      : '';
    const response = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: `Generate a concise multiple-choice question about ${context === 'ECONOMY' ? 'finance/banking' : 'ecology/sustainability'}.${excludeText} Return valid JSON.`,
      config: {
        responseMimeType: 'application/json',
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            question: { type: Type.STRING },
            options: { type: Type.ARRAY, items: { type: Type.STRING } },
            correctIndex: { type: Type.NUMBER },
            explanation: { type: Type.STRING },
            category: { type: Type.STRING },
          },
          required: ['question', 'options', 'correctIndex', 'explanation', 'category']
        }
      }
    });
    return JSON.parse(response.text || '{}') as AIQuestion;
  };

  try {
    return await callWithRetry(fetchQuestion);
  } catch (error) {
    console.error("AI Question Error, using local fallback:", error);
    const pool = LOCAL_FALLBACK_QUESTIONS[context];
    const availableQuestions = excludedQuestions
      ? pool.filter(q => !excludedQuestions.includes(q.question))
      : pool;
    const fallbackPool = availableQuestions.length > 0 ? availableQuestions : pool;
    return fallbackPool[Math.floor(Math.random() * fallbackPool.length)];
  }
};

export const getAIEnumeration = async (context: 'ECONOMY' | 'SUSTAINABILITY'): Promise<AIEnumeration> => {
  const fetchEnum = async () => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const response = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: `Provide a theme and a list of at least 20 terms for ${context === 'ECONOMY' ? 'finance' : 'nature'}. Return valid JSON.`,
      config: {
        responseMimeType: 'application/json',
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            theme: { type: Type.STRING },
            expectedTerms: { type: Type.ARRAY, items: { type: Type.STRING } },
            reward: { type: Type.NUMBER },
          },
          required: ['theme', 'expectedTerms', 'reward']
        }
      }
    });
    const result = JSON.parse(response.text || '{}') as AIEnumeration;
    return { ...result, category: context === 'ECONOMY' ? 'Financial Literacy' : 'Ecosystem' };
  };

  try {
    return await callWithRetry(fetchEnum);
  } catch (error) {
    console.error("AI Enumeration Error, using local fallback:", error);
    const pool = LOCAL_FALLBACK_ENUMS[context];
    return pool[Math.floor(Math.random() * pool.length)];
  }
};

export const validateEnumTerms = async (theme: string, userInput: string, expectedTerms: string[]): Promise<{ validTerms: string[] }> => {
  const validate = async () => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const response = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: `Context: Educational Game. Theme: "${theme}". User List: "${userInput}". 
      Task: STRICTLY filter the user's list. Return JSON { "validTerms": [] } containing ONLY items that differ from the theme but are historically/factually CORRECT examples of the theme. 
      Reject vague words, generalities, or incorrect items. 
      If the user lists items that match the meaning of the provided 'Expected Terms' list (${expectedTerms.slice(0, 10).join(', ')}...), accept them.`,
      config: {
        responseMimeType: 'application/json',
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            validTerms: { type: Type.ARRAY, items: { type: Type.STRING } },
          },
          required: ['validTerms']
        }
      }
    });
    return JSON.parse(response.text || '{ "validTerms": [] }');
  };

  try {
    return await callWithRetry(validate);
  } catch (error) {
    console.error("Validation Error, falling back to strict local check:", error);

    // Strict Fallback: Check if user items are in the expected list
    const userItems = userInput.split(/[,\n]/).map(t => t.trim().toLowerCase()).filter(t => t.length > 2);
    const expectedLower = expectedTerms.map(t => t.toLowerCase());

    const valid = userItems.filter(item =>
      expectedLower.some(expected => expected === item || (expressionMatch(expected, item)))
    );

    return { validTerms: valid };
  }
};

// Helper for rough fuzzy matching in fallback
const expressionMatch = (expected: string, actual: string) => {
  return expected.includes(actual) || actual.includes(expected);
};
